clean cache : npm cache clean -f
check version node: node -v
check version nom : npm -v
create new angular: ng new <nameproject> --routing
open project: ng serve --open.
xem version in angular : ng --version.
upgrade angular: ng update @angular/cli @angular/core

tạo 1 ứng dụng : ng new <nameproject> --routing : dùng để phân trang và thêm các đường dẫn
upgrade version: ng update @angular/cli @angular/core
xem version hiện tại:ng --version.
run project: ng serve --open./ ng serve -o
tạo 1 component : ng generate component <namecomponent>
tạo 1 service: ng generate service <nameservice>
cài type timestamp in angular: npm i -D @angular-builders/timestamp
sử dụng in-memory web api  thì sẽ không cần set up a server về HttpClient: npm install angular-in-memory-web-api --save

angular là được xây dựng trên những khối xây dựng cơ bản gọi là component
chúng chịu trách nhiệm show dữ liệu, lắng nghe sự kiện từ người dụng.

trong component của angular có 3 file chính:
component.ts :là component class code, được viết bằng typescript.
component.html: là component template, được viết = html chịu trách nhiệm show giao diện người dùng.
component.css: là component css, trang trí cho html ( mình sử dụng: scss).

Trong angular sẽ có 4 thành phần chính để cho angular hoạt động:
-component: chịu trách nhiệm xử lý các dữ tiệu của service sau đó hiển thị lên màn hình.
- service: lấy data từ các api từ phía server.
- model: là các class entity chịu trách nhiệm map các giá trị từ các json của api.
- app-routing.module.ts: chịu trách nhiệm tạo ra các URL cho các coponent.

Khi gọi 1 function :
   nameFunction(nameParameter:type){
	// khai báo biến trong function sử dụng let or const
	// code here
	// chỗ này cũng có thể return value.
   }

src.styles.scss: css chung cho các component.

muốn sử dụng edit property (input):
-<input  [(ngModel)]="nameproperty.value">text</input>
- thêm import { FormsModule } from '@angular/forms'; trong file app.module.ts

muốn gọi 1 list element:
- *ngFor="let item of listtems"

event của các thẻ: cú pháp (name event)="method()"

create method trong file name.component.ts:
- namemthod(): value-reture{
// code here
}
(valuereturn: giá trị trả về của method)

condition in angular: *ngif="DK"

Truyền value from other component (app-heros) to this component(app-hero-detail):
- <app-hero-detail [inputHero]="heroDetail"></app-hero-detail> ( inputHero: là giá trị sẽ nhân value từ 'heroDetail').
- import { Component, OnInit, Input} from '@angular/core'; trong file hero-detail,component.ts
- thêm @Input() inputHero: Hero; (inputHero là giá trị được nhận từ component 'app-heros')

cách sử dụng service:
- khởi tạo 1 service: ng generate service <nameservice>
- tạo các method xử lý lấy dữ liệu (get data in http)
- gọi service trong các component.
- khởi tạo service vd: constructor(private heroService: HeroService) { }
- tạo 1 method truyền value từ service lên component vd:
  getHero(): void{
    this.heros =this.heroService.getHero();
  }
- gọi method trong hàm: (mục đích là gọi các method khi component được khởi tạo.)
  ngOnInit() {
    this.getHero();
  }

constructor: dùng để khởi tạo các contructor vd: service, component, ....

ngOnInit: dùng để gọi xử lý các method khi đươc khởi tạo.

sử dụng Observable để angular sẽ phải wait data từ phía server trả về,
và trình duyệt sẽ không bị chết trong lúc đợi server trả về.
Đây là phương thức lấy dữ liệu rất hữu hiệu từ phía server.
- import :import { Observable, of } from 'rxjs'; trong service.
- gọi 1 method sử dung Observable vd:
  getHeroes(): Observable<Hero[]> {
  	return of(HEROES);
  }
- convert dữ liệu từ Observable<Hero[]> -> Hero[]:
  getHeroes(): void {
  	this.heroService.getHeroes()
      	.subscribe(listHero => this.heroes = listHero);
  }
(với this.heroes là 1 parametor đã được khai báo)

constructor(public messageService: MessageService) {}
constructor(private messageService: MessageService) {}
+ Khi khai báo private nghĩa là messageService sẽ không được thực thi trên file component.html
muốn thực thi trên html thì sẽ phải khởi tạo parameter sau đó truyền dữ liệu vào parameter đó.
+ Khi khai báo public thì messageService có thể được gọi một cách trực tiếp trên component.html
các method, các parametor ở service có thể gọi được trực tiếp trên component.html

route: url của các component được sử dụng để điều hướng trong angular.
- sử dụng <router-outlet> : điều hướng các component sẽ được display như thế nào.
(vùng này sẽ là nơi show component theo route)
- trong file app-routing.model.ts thêm:
 {path:'hero' , component:HerosComponent} dùng để khai báo 1 route có path ( url : hero) của component (HerosComponent)
trong const routes: Routes = []; (quản lý các route.)
- muốn sửa dụng các route: <a routerLink="/namepath"> url route</a>

truyền pathvariable:
- {path:'herodetail/:id', component:HeroDetailComponent},( id: pathvariable)
- link route:  <a routerLink="/herodetail/{{item.id}}" >here</a> ( {{item.id}}: value
- import { ActivatedRoute } from '@angular/router'; (khai báo thư viện để lấy giá trị của pathvariable.
- khai báo trong contructor.
- const value= this.route.snapshot.paramMap.get('namePathvariable'); (lấy thông tin pathvariable của url.
- const id = +this.route.snapshot.paramMap.get('id'); ( convert string to number).

Xử lý với api:
- Sử dụng api với Observable để có time wait from server.
- vd api: http://dummy.restapiexample.com/api/v1/employees
- khai báo và import: [HttpClientModule] trong app.module.ts (import { EmployService } from './service/employ.service';)
- tạo 1 entity có tác parameter thoả mãn api.
- tạo 1 service để gọi và xử lý api
- khai báo constructor(private http: HttpClient) { } trong service.
- nếu api đó cần 1 or multi header:  httpOptions = {
    headers: new HttpHeaders({
      'Content-Type':  'application/json',
      'Authorization': 'my-auth-token'
    })
  };
- viết method gọi api.
- tạo 1 component
- khai báo constructor(private positionService :PositionService) { } trong component.
- truyền parameter lên html.

view, check object trong angular dưới dạng json.
 {{nameObject | json}}

xử lý form:
+cách 1:
- tạo 1 class entity chứa các parameter tương ứng của form.
- gọi 1 paramenter khai báo class đó trong component.
- Thêm [(ngModel)]="nameObject.nameParameter" name="nameParameter" vào 1 trong các loại input, select.

+cách 2: sử dụng reactive forms validation.

cài đặt bootstrap jquery poper.js trong angular:
+ sử dụng cli: npm install bootstrap jquery popper.js --save

+ thêm trong file angular.json:
 "styles": [
     "src/styles.css",
     "node_modules/bootstrap/dist/css/bootstrap.min.css"
 ],
 "scripts": [
     "node_modules/jquery/dist/jquery.min.js",
     "node_modules/popper.js/dist/umd/popper.min.js",
     "node_modules/bootstrap/dist/js/bootstrap.min.js"
 ]

cách debug trong angular: debugger

có thể tạo ra module chứa nhiều component. service, routing nhằm mục đích cho dễ quản lí 1 module, một ,màn hình hoặc 1 cụm màn hình nào đó
cách tạo module và routing : ng g m <tên-module> --routing
bên trong module đó vẫn có thể tạo component:
ng g c <tên-module>/<tên-component>
bên trong file: app-routing.module.ts thì khai báo module
ví dụ:
{path: "hotel", loadChildren:() => import("./hotel/hotel.module").then((result => result.HotelModule},
trong Routes

và các path con thì sẽ được khai báo trong <tên-module>-routing.module.ts

mục đích của việc chia module giúp giảm thời gian tải trang khi có quá nhiều module cần load 1 lúc
sẽ dẫn đến khi nào gọi đến module nào thì module đó được load
ngoài ra:
có thể thêm {preloadingStrategy: preloadingAllModules}  trong file app-routing.module.ts phần import
mục đích:
giúp app có thể load được những module nhẹ, sớm khi các module đó chưa cần thiết gọi đến.

trong service đối với providedIn
nếu: root thì sẽ được khởi tạo duy nhất 1 lần dùng cho toàn app
nếu: any thì mới mỗi 1 module thì sẽ được khởi tạo 1 instance chi module đó.

các bước tạo 1 module mới:
b1: ng g m <tên-module> --routing
b2: thêm path trong app-routing:
ví dụ:
path:'',
component:<tên-component>,
canActivate:[<tên-hàm-bảo vệ>],
loadChildren:()=> import('<tên-đường-dẫn-module>').then((m)=> m.<tên-module>
Chú ý:
với component:<tên-component> thì tên-component đó sẽ đại diện cho 1 component có <router-outlet></router-outlet> trong file html
với canActivate dùng để check token có còn thời hạn hiệu lực không

b3: trong module của mình sẽ bổ sung các module cần thiết ở import
trong declarations: nhằm chỉ ra các component, pipe, directive được định nghĩa trong module này (bắt buồn liệt kê toàn bộ)
trong providers: dùng để khai báo các class có @Injectable() (service: được sử dụng trong module này )
đối với các state và facade thì mình sẽ thêm @Injectable() trên class

resolver:
tác dụng:
được sử dụng để router sẽ đợi cho đến khi data được trả về trước khi route được kích hoạt (trước khi màn hình được hiển thị)
bước 1: tạo 1 file name.resolver.ts
bước 2: file sẽ implements Resolve<Obect> ( object: là đối tượng sẽ nhận response trả về từ server)
bước 3:
cách 1: truyền id vào api id = route.paramMap.get('id'); (cách này không nên dùng vì nó không có sự cập nhật lại (đồng bộ) khi có sự thay đôi từ router).
cách 2: this.route.paramMap.subcribe((params: ParamMap) =>{ id = parseInt(params.get('id');});

với route: ActivatedRouteSnapshot
bên trong file sẽ thực hiện gọi api và return về observable, ngoài ra sẽ thực hiện xử lý check error ở đây thông qua catchError
và chuyển hướng trang thông qua (Router).
bước 3: trong file routing sẽ bổ sung thêm resolve vào path mà mình muốn
ví dụ:
{
path:'list',
component: file-component,
resolve:{name-list: file-resolver}
}
bước 4: bố sung thêm  file resolver của provider trong file module.
bước 5: gọi ActivatedRoute trong constructor của component.
bước 6: gọi resolve trong component
ví dụ:
cách 1:
this.value = this.router.snapshot.data['name-list']; or this.router.snapshot.data.name-list;=> không cần subscribe (cách này không nên dùng do không có sự cập nhật lại
khi có sự thay đổi từ router)
cách 2:
this.router.data.subscribe( (val) =>{ this.value = val; });

với router: ActivatedRoute được khai báo trên constructor.

@input, @putput:
mục đích:
truyền dữ liệu qua lại giữa component cha và component con
input: truyền dữ liệu của cha cho con
output: truyền dữ liệu của con cho cha (qua event)
cách dụng
với input:
<name-component-con [property-con]="property-cha"></name-component-con>
với ouput:
<name-component-con (function-con)="function-cha"></name-component-con>
chú ý:
với output thì sẽ sử dụng EventEmitted<kieu-du-lieu>();
sử dụng two-way binding với ngModel
với componenet con:
@Input()tem: kiểu dữ liệu
@Output()tenChange = new EventEmitter<Kiểu dữ liệu>();
trên conponenet cha:
[(ten)]="value-cha"
chú ý: input: xyz => output: xyzChange


template variable:
mục đích:
được sử dụng để định dang 1 component hay 1 thẻ trên html
cú pháp: #varnam
để xác định với 1 component cụ thể: #varname="name-component"
có thể tác động trực tiếp đến component đó thông qua #varname

@ViewChild
mục đích:
được sử dụng để tác động đến component con của một component hoặc tác động đến 1 htmlElement
cú pháp:
@ViewChild('var-name',{static: true}) varname: Component; (component)
@ViewChild('var-name', {static: true}) varname: ElementRef<HTMLDivElement> (htmlElement)

form sử dụng:
ViewChild(selector: string | Function | Type<any>, opts?: {
  read?: any;
  static?: boolean;
})

@ViewChildren
mục đích:
được sử dụng nếu trong component cha có nhiều cùng la 1 component con và bạn muốn tác động đến các component con đó.
cú pháp:
@ViewChildren('var-name') toggleList: QueryList<ToggleComponent>;

ng-content:
mục đích:
được sử dụng khi muốn truyền một template vào trong 1 component con.
cú pháp:
trong component con
<ng-content select="component-name"></ng-content>
<ng-content select="html-tag"></ng-content>
<ng-content select="[attr]"></ng-content>
<ng-content select=".class-name"></ng-content>
<ng-content select="component-name.class-name[attr]"></ng-content>
default: get all
<ng-content></ng-content>

ng-template:
mục đích: dùng để render lên UI khi có *ngif hoặc ngTemplateOutlet sử dụng.
phần HTML trong ng-template không bao giờ hiển thị 1 cách trực tiếp ở nơi nó được định nghĩa.
cách sử dụng:
1- dùng với *ngif
2- khi 1 phần UI element bị lặp lại nhiều lần trong chính component đó nhưng phần UI đó quá nhỏ để có thể tách ra thành 1 component.
kết hợp sử dụng với template variable, ng-container, ngTemplateOutlet
cos thể truyền ng-template vào component con thông qua @Input.
khai báo @Input: @Input() name-template: TemplateRef<any>;

ngTemplateOutlet
mục đích: sử dụng để render ng-template lên UI
cú pháp: [ngTemplateOutlet]="name-template"
ngoài ra sử dụng [ngTemplateOutletContext]="{property-right:'value'}" dùng để truyền value và trong ng-template
ví dụ:
<ng-template let-property-left="property-right" #template>
{{property-left}}
</ng-template>
<ng-container [ngTemplateOutlet]="temlate" [ngTemplateOutletContext]="{property-right='value'}"

ng-container: là 1 custom html tag dùng để render trên UI, sẽ không có thêm những tag không liên quan tránh việc ảnh hưởng đến style
nó sẽ chỉ render những thẻ bên trong template

@Injectable vs @Inject:

sử dụng Injectable với các kiểu dữ liệu tự định nghĩa -class mà chúng ta tạo ra
sử dụng Inject với kiểu dữ liệu nguyện thuỷ(primitive) boolean, string, number để báo cho angular biết và chúng ta sẽ cần config provider tương ứng cho chúng
hoặc muốn sử dụng một token khác cho tham số thay vì kiểu dữ liệu của nó

ví dụ:
@Inject('value-inject') value: string
lúc này {provide: 'value-inject', useValue:'value of inject'}

cách sử dụng:
depency injection: được sử dụng trong 2 cấp độ: module và trong chính component/ directive.
đối với cấp độ modele thì toàn bộ các thành phần bên trong NgModule sẽ sử dụng cùng 1 instance
đối với cập độ component/ directive thì mỗi 1 component/ directive sẽ tạo ra 1 instance của riêng nó và 2 instance này khác nhau chúng sẽ chỉ được sử dụng trong chính nó.

chúng ta có thể inject parentcomponent vào childcomponent và thực hiện hành động
ví dụ:
export class ChildCoponent{
constructor(private parentComponent: ParentComponent){}
}

sử dụng lại component đã tồn tại trong application bằng cách sử dụng provider để override:
  providers: [
    {
      provide: ExistedComponent,
      useExisting: NewComponent,
    }
  ]
export class NewComponent extends ExistedComponent{
}

các thành phần trong module:
declarations: thành phần định nghĩa các component, directive, pipe trong module đó sử dụng
imports: khai báo các module khác sẽ được sử dụng trong module này.
providers: cung cấp các depency injection được sử dụng trong module này (service, facade, state)
exports: chứa các thành phần mà được module này cho phép import (component, service, module, pipe, directive)

provider:
trong provider có userClass và useExisting
useClass: thể hiện class đó sẽ được sử dụng với provide nào
ví dụ:
providers:[
  {
    privide: name,
    userClass: ClassIsUsed,
  }
]
useExisting: thể hiện là class đó sẽ sử dụng provider nào.
providers:[
  {
    privide: name,
    useExisting: ClassUse;
  }
]

các giá trị trong proprovidedIn của service:
root: nó sẽ là instance duy nhất cho cả application.
platform: nó sẽ là instance duy nhát cho tát cả application trong 1 page
any: nó sẽ tạo ra 1 instance với mỗi một childmodule sử dụng nó ( nó làm việc trên NgModule Injector và không làm việc trên element Injector)

observable:
được sử dụng để có thể tiến hành nhiều giá trị bất đông bộ về mặt kiến trúc nó được coi là các stream, các data sẽ được chảy qua các luồng xử lý
để có thể biến đổi thành các dạng mà bạn mong muốn ở điểm cuối của stream
để thực thi một observable (observable execution) thì ta sẽ phải invoke function bằng cách (subscribe)
sau khi bạn invoke, và khi có 1 signal (next, error, complete) gửi đi thì những gì chúng ta cung cấp cho observable phía trên sẽ được gọi là tương
tác lại tín hiệu
có 3 kiểu observable gửi đi:
next: gửi đi một giá trị.
error: gửi đi một javascript lỗi, exception
complete: không gửi đi giá trị nào, nhưng nó sẽ gửi đi tín hiệu để báo stream đã completed
error và complete chỉ xảy ra duy nhất 1 lần (nếu có error thì không có complete nếu có complete thì không có error)
observable.subcribe() sẽ chuyển hoá các callbacks thành observable object tương ứng , bạn có thể truyền vào các hàm rời rạc khác nhau nhưng cần truyền
đúng thứ tự tương ứng.

với:
next -> value
error -> err
complete -> ()

nếu bạn không muốn truyền error handler function, hãy truyền null/ undefined:
observable.subcribe(
  value =>{},
  null,
  ()=>{}
)

muốn thực hiện huỷ một observable excecution thì chúng ta sử dụng subscription có chứa method quan trọng là unsubscribe, khi method này được gọi,
execution sẽ bị huỷ
một subscription có thể chứa nhiều subscription con, băng cách subcription cha gọi method add để thêm các subscription con mà không phụ thuộc vào subcription cha.
khi subscription cha unsubscribe thì các subscription con cũng bị unsubscribe.

các operator:
- of(): dùng để tạo ra 1 observable từ bất kì giá trị primitive, array, function, object,..
chú ý với 1 subscribe thì sẽ trả ra 1 observable

- from(): dùng để tạo ra observable từ interable hoặc promise
với iterable: array, map, set, string
với 1 subscribe sẽ trả ra 1 list các observable

- defer(): nhận vào 1 observableFactory và sẽ trả về observable. defer() sẽ sử dụng observableFactory để tạo 1 observable mới cho mỗi subscriber
lợi ích: chúng ta cần rety 1 observable nào đó mà cần so sánh với 1 giá trị random để quyết định xem có thực thi hay không.
thì defer() kết hợp với retry là giải pháp cực kì hiệu quả.

debounce và throttle
cách sử dụng:
được sử dụng với những sự kiện: resize, scroll, keyup, keydown hoặc những chức năng tìm kiếm văn bản mà kích hoạt sự kiện không
giới hạn.làm giảm việc client truy vấn qua nhiều đến db, giảm tải công việc của server.
-debounce: giống với các làm việc của thang máy(thang máy trung bình sẽ chờ 5s, khi có người đi đến, thang máy mở ra và kích hoạt thêm 5s
chờ đến khi không còn ai đến và hết 5s thì thang máy sẽ đóng lại)
-throttle giống với tàu điện ngầm hoặc xe buýt(nó không cần biết bao nhiêu người đến, chỉ quan tấm đến phút thứ 15 là tự động đóng lại)
-pluck(): yêu cầu lấy ra những giá trị từ một property trong object.
-reduce(): xử lí giá trị acc( giá trị cộng dôn) và giá trị curr (giá trị hiện tại) đến khi source complte thì nó sẽ trả ra giá trị cuối cùng
- scan(): xử lí giá trị acc và giá trị curr nhưng sau mội 1 lần emit trả ra giá trị.
-first(): sẽ emit giá trị đầu tiên của observable rồi complete
chú ý: nếu observable tự complete trước giá trị empty/ of() mà không có giá trị nào thì throw EmptyError và được sử dụng với from.
-last(): sẽ emit giá trị cuối cùng của observable rồi complete
chú ý: nhận vào 2 giá trị predicate, defaultvalue
sẽ throw Error nếu chỉ có predicate và khôgn có giá trị thoả mãn
sẽ throw emptyError nếu observable tự complte.
sẽ emit giá trị defaultvalue nếu có predicate, defaultvalue mà không có giá trị thoả mãn
sử dụng với from.
-find(): sẽ emit giá trị đầu tiên mà thoả mãn được điều kiện predicate (bắt buộc), nó sẽ không emit error (sẽ emit undifined) nếu như không có giá trị
nào thoả mãn.
-single(): sẽ giống giới first() nhưng sẽ throw error nếu có nhiều hơn 1 giá trị thoả mãn, sex không emit error (sẽ undifined) nếu không
có giá trị thoả mãn.
-take(): dùng để lấy số giá trị emit từ observable sử dụng với from.
-takeUnit(): sẽ emit giá trị đến notifer được emit (nhận vào là 1 notifer: observable).
-takeLast(): số phần tử từ giá trị cuối cùng.
-skip(): dùng để bo qua n giá trị đầu không được emit
-zip(): sẽ gom tất cả các giá trị được emit bởi children observable theo cấp
ví dụ:
combineLatest(of(1, 2, 3), of(4, 5, 6, 11), of(7, 8, 9)).subscribe(observer);
output:[1, 4, 7], [2, 4, 7], [3, 6, 9]
chú ý:
zip sẽ complete khi 1 trong các children observable complte.
zip sẽ throw nếu một trong các children throw error
-race():sẽ emit giá trị của observable nào emit đầu tiên( nhanh nhất)và sẽ lại đi lặp lại cho đến 1 trong các children observable complete.
-merge(): không quan tâm đến thứ tự của các children oberservable emit không bị giới hạn bởi việc các observable con phải complete thì
observable kế tiếp được subscribe.
chú ý:
emit bất cứ observable nào emit
throw nếu 1 trong children observables throw error.
complete khi tất cả children observable complete
-concat(): sẽ hoạt động tương tự cho lần lượt từng children observables cho đến khi không còn observable nào thì concat sẽ compelete
- retry(): sẽ resubcribe vào source observable  khi có error emit từ source, cần truyền tham số để thể hiện số lần được retry nếu
không sẽ retry không giới hạn
ngoài ra chúng ta có retryWhen để có thể control vào quá trình retry (khi nào retry)
-every(): sẽ trả về true nếu tất cả các emit value đêu thoả mãn predicate.
-iff(): cho phép lựa chọn observable tương ứng với hàm điều kiện khi thực hiện subscribe.
ví dụ: iff(() => predicate, of(trueresult), of(falseresult))
-groupBy(): được sử dụng để nhóm các observable thành một mảng theo key (chúng ta chọn property). sử dụng groupby sẽ trả về nhiều mảng
chứa nhiều observable theo key.
-switchMap(), concatMap(), mergeMap(), exhaustMap(): một trong những HOOs (higher Order Operators) dùng để gộp các obserbale thành một
observable
-finalize(): sẽ nhận vào 1 callback, callback này sẽ thực thi obserable khi complete/ error
ví dụ: được sử dụng stop loader/spinner khi request API được thực hiện xong, cho dù lỗi hay không lỗi.

với pipe, cần có đuôi là subscribe ở component để thực thi gọi api
- pipe: nhằm mục đích lọc các thành phần, giá trị để đến giá trị cuối cùng cho subscribe.
- tap: mục đích là sử dụng không return
- flatMap: mục đích chuyển đổi observable thành 1 observable khác ( có return)
chú ý với flatMap: khi return value cần of(value)
- catchError trả ra lỗi trong pipe
- filter: dùng để lọc các điều kiện
- mergeMap: thực hiện merge các giá trị nhưng các stream sẽ chạy đồng thời (flatMap là tên gọi khác của mergeMap)
- concatMap: cho phép 1 stream chạy trong 1 thời điểm( phải đợi stream trước complete thì stream sau mới được chạy tiếp)
- switchMap: chỉ cho phép 1 stream chạy, nếu stream trước chưa complete thì sẽ bị unsubscribe.
- exhaustMap: stream sau sẽ bị bỏ qua nếu stream trước chưa hoàn thành
- khi thực hiện flapMap return ra value thì value đó sẽ là value tiếp theo được thực hiện ở hàm dưới và cuối cùng là subcribe.
- trong pipe giá trị trả về sẽ bị biến đổi theo thứ tự từ trên xuống (nếu qua flapMap, switchMap,..) các hàm return, sau cùng sẽ
trả về cho hàm subcribe()
-reduce: là hàm lấy ra 1 giá trị mong muốn được thực thi tường phần tử ( từ trái -> phải) 1 array ( có thể tổng các phần tử, min, max)
-map: là hàm biến đổi tất cả các giá trị theo 1 điều kiện được chỉ định và sau đó sẽ return là object mong muốn.
cú pháp: reduce(giá trị tích luỹ, giá trị hiện tại của mảng =>{body});
với body:
là nơi thích hiện logic và trả về giá trị mới cho giá trị tích luỹ
ví dụ:
giá trị tích luỹ + giá trị hiện tại
giá trị tích luỹ < giá trị hiện tại ? giá trị hiện tại : giá trị tích luỹ

- đối với những param có thể không cần thiết, thêm '?' sau param đó
ví dụ:
value?: string;
- đối với những param trong method không cần thiết, thêm phải để giá trị default
ví dụ:
post(path: string, login: boolean = false){}

-for/ for in : cho phép bạn truy cập vào index của mảng
-forEach/ for of: cho phép bạn truy cập trực tiếp đến giá trị của phần tử

các cách coppy trong js:
có: shallow copying và deep copying
với shallow copying:
1-Object.assign(target,source)
2-spread operator có thể đúng sử dụng với array, objct
ví dụ:
[...obj] => array
{...obj} => object
với deep copying:
JON.parse(value-string)=> parse string to object
JOS.stringify(value-object)=> parse object to string
kết hợp:
JOSN.parse(JSON.stringify(value-object),form-object);
với form-object có thể có, có thể không
với shallow copying khi clone giá trị gốc, mà thay đổi giá trị gốc thì động thời giá trị clone cũng bị thay đổi
với deep copying khi clone giá trị gốc, mà giá trị gốc thay đổi thì giá trị clone không thay đổi.
hạn chế với deep copying:
nếu tham số của bạn là NaN, undefined, new Function(), function(){},.. đối khi những tham số đó bị mất.

Generics trong typescript:
mục dích:
giúp cho các functions/ components/ modules không nhất thiết phải chỉ định kiểu dữ liệu lúc khởi tạo. khi functions/ components/ models
được sử dụng thì chúng sẽ được khai báo báo kiểu dữ liệu
cách dùng:
type ObjectRoot = { param: type };
function nameFunction<T extends ObjectRoot>(items :T[]): T {
// code here
return object of type T;
}
chú ý: nên sử dụng generics khi functions/ components/ models return ra chính kiểu dữ liệu của object giống với kiểu dữ liệu của object
đầu vào.
nếu functions/ components/ models đã return ra 1 kiểu dữ liệu cố định thì không cần sử dụng. kể cả khi ta sử dụng functions/ components/
models có kiểu dữ liệu lớn hơn kiểu dữ liệu truyền vào thì chúng vẫn hoạt động. vì khi chúng ta truyền thừa kiểu dữ liệu thì
functions/ components/ models đó không sử dụng những kiểu dữ liệu đó cho nếu functions/ components/ mdoels sẽ không bị ảnh hưởng.

+ngrx
là một framework được xây dựng để phát triển  "reactive application" trong ứng dụng angular.
ưu điểm:
-single source of truth: tất cả các state của ứng dụng được lưu trong 1 objec tree duy nhất. vì vậy có thể chia sẻ state giữa các component
trở nên rõ ràng.
- hầu hết mọi thứ trong ngRx đề sử dụng pure function nên việc test trở nên dễ dàng.
-scaleable: ứng dụng sẽ dễ dàng trong việc mở rộng vì cấu trúc của NGrx trở nên rõ ràng.
các thành phần:
store: nơi lưu trữ các state.
action: thể hiện các hành động khi muốn thay đổi state,
reducer: thực hiện chuyển đổi state từ trạng thái này -> trạng thái kia.
selector: lấy ra state mong muốn trong store.

+trong việc xử lý bất đồng bộ (async) của js:
sử dụng await đối vơi việc gọi function khác xử lý
có thể sử dụng return function
hoặc có thể sử dụng: return await
đối với await:
nếu hàm có xử lý có try/catch thì khi hàm xử lý await mà lỗi thì catch sẽ bắt lỗi của hàm.
đối với returm:
nếu hàm có xử lý try/catch thì khi hàm xử lý return mà lỗi thì nó sẽ không vào catch mà sẽ vào hàm xử lý return.
đối với return await:
nếu hàm xử lý try/catch thì khi hàm xử lý return ra giá trị xử lý thành công và catch ra giá trị lỗi của hàm.

+kĩ thuật lazy loading:
trong thẻ img có thuộc tính loading với 3 giá trị:
auto: giá trị mặc định phụ thuộc vào hành vị của từng trình duyệt tương tự không thêm loading.
lazy: trì hoẵn tải tìai nguyên về cho đến khi đạt 1 khảon cách nào đó từ khung nhìn.
eager: tải tài nguyên ngay lập tức, bất kể vị trí của nó ở đâu.
ví dụ:
<img src="awesome-photo.jpg" loading="lazy">

đối với các trình duyệt không hỗ trợ thì tạo 1 polyfill hoặc dùng thư viện thứ 3 (LazySizes).
thuộc tính loading có thể dùng để phát hiện xem trình duyệt có hỗ trợ tính năng không:
if ('loading' in HTMLImageElement.prototype) {
  // trình duyệt có hỗ trợ
} else {
  // sử dụng polyfill hoặc thư viện của bên thứ 3
}

sử dụng với LazySizes:
https://github.com/aFarkas/lazysizes

lưu ý:
tránh sử dụng lazy loading với những ảnh trong khung nhìn đầu tiên.

cách thực hiện clone file:
function cloneFile(file: File): Observable<File>{
 if(!(file&& file instanceof File)){
  return of(null);
 }
 const reader = new FileReader();
 const stream$ = fromEvent(reader, 'loadend');
 return stream$.pipe(
  map(() =>{
   const blob = new Blob([reader.result]);
   return new File([blob], file.name, {
    lastModified: file.lastModified
   });
  })
 );
}

Partial: cung cấp cách thức để toàn bộ các property của kiểu dữ liệu đó được set là optional (không bắt buộc)
ví dụ:
export interface User{
 id: numebr;
 name: string;
}

const user : Partial<User> ={id:0};

trong angular có cung cấp 2 giải pháp cho form là template-drivens forms và reactive forms (model-driven forms)
- template-driven forms: hoạt động chủ yếu dựa trên các directives trên template như ngModel ngForm,.. dạng này sử dụng
two-way binding để update data model giữa template  và component.
- reactive forms: xây dựng form từ các model , là các object có một chức năng đặc biệt để quản lý các form input.

sự khác nhau giữa submit và ngSubmit:
-submit: sẽ thực hiện submit form và reload trang web khi thực hiện submit hoặc khi sinh ra exception.
-ngSubmit: sẽ thực hiện submit form và không reload trang web khi thực hiện submit.

+Best practices:
Nên sử dụng ngSubmit cho việc listen form submit (vì nó sẽ không reload lại web).
+lưu ý:
ngSubmit có thể áp dụng cho cả reactive forms.

có 2 register control với form
[ngModel]: là property binding, tức chúng ra binding property từ component lên template. (binding 1 chiều)
[(ngModel)]: là two-way data binding, lúc này nó sẽ kết hợp giữa property binding và event binding (đồng bộ dữ liệu giữa template
và component) (binding 2 chiều)

angular form validation:
validation status cho một control sẽ bao gồm status
touched:(true) là khi người dùng đã focus vào control rồi sau đó blur (nhảy ra) khỏi control
untouched:(true) là chưa đụng chạm gì, hoặc lần đầu focus và chưa bị mất focus.
dirty: (true) là nếu người dùng thay đổi giá trị của control - ví dụ nhấp 1 kí tự vào ô input hoặc focus vào rồi xoá đi.
pristine:(true) là người dùng chưa thay đổi value của control mặc dù người dùng có thể touch nhưng chưa sửa đổi.

template-driven forms validation:
required: yêu cầu form control không được phép bỏ trống.
minlength: yêu cầu form control phải có value có length ít nhất bằng một giá trị nào đó.
maxlength: yêu cầu form control phải có value có length không được vượt quá một giá trị nào đó.
pattern: yêu cầu form control phải có value thoả mãn một partten nào đó (regEx)
email: yêu cầu form control phải có value thảo mãn pattern của một email.

trong template form cho phép xác thực 1 cách trực tiếp sửa đổi dữ liệu ở trên template, nhưng ít sự rõ ràng hơn reactive form.
vì chúng dựa vào chính các chỉ thị ở trên template, cùng với đó là sự bất biến dữ liệu theo dõi sự thay đổi bất đồng bộ.

reactive forms (model-driven forms)
là 1 phương pháp để tạo ra form, không sử dụng ngModel, required,... thay cho việc tạo object ở các component, rồi tạo form từ
chúng.

lưu ý: reactive forms là sync, template-driven forms là async.

trong reactive form, chúng ta tạo toàn bộ form control tree ở trong constructor (hoặc trong onInit) nên có thể dễ dàng truy cập
các phần tử của form ngay tức thì.
form state ở trong reactive form là immutable ( bất biến), mỗi sự thay đổi của form state sẽ tạo ra 1 state mới.
reactive thì sử dụng khá nhiều observable streams, ví dụ valueChanges, statusChanges. bạn hoàn toàn có thể combine (phối hợp)
và manipulate (vận dụng) stream như những observable thông thường.
validation trên reactive form cũng rất dễ dàng, nó chỉ là 1 function và bạn có thể hoàn toàn thay thế trong khi application run
sử dụng:
cần import ReactiveFormsModule trong module cần sử dụng.
AbstractControl: là class base của 3 thành phần (formGroup, formControl, formArray)
-formControl: là đơn vị nhỏ nhất của form, dùng để track (theo dõi) thông tin value, validation của form control ví dụ như input,
checkbox, ...
-formGroup: là một tập hợp của các control/group/array (AbstractControl) dạng như một object, nó có thể chứa các value đơn hoặc các
object khac.
-formArray: là cấu trúc dưới dạng array, để quản lý các AbstractControl theo dạng mảng, dùng trong trường hợp có thể thêm bớt phần
tử 1 cách linh hoạt. có thể add or remove
thông thường mỗi 1 form sẽ bắt đầu bởi một formGroup, nó sẽ khai báo các AbstractControl trong nó.
ví dụ:
trong componenet:
siginForm = new FormGroup(
  {
    username: new FormControl("value"), // <= value default
    password: new FormControl(""),
    gender: new FormControl(true)
  }
)
binding form (template):
-để binding fomrControl thì chúng ta sử dụng formControlName
<form [formGroup]="siginForm">
  <input formControlName="username">
</form>

+FormBuilder Service: giúp cho việc khởi tạo form nhanh hơn không cần new nếu như form có số lượng control lớn.
cần inject FormBuilder vào constructor.
ví dụ:
 signInForm: FormGroup;
constructor(private fb: FormBuilder) {}
ngOnInit(){
  this.signInForm = this.fb.group({
    username: 'value',
    gender:true
    password: '',
  })
}
+update value trong reactive form qua patchValue hoặc setValue:
-Đối với formControl: sẽ không có sự khác giữa 2 phương thức patchValue và setValue.
-Đối với formGroup và formArray: thì patchValue sẽ cập nhật các giá trị khai báo tương ứng trong object value truyền vào,
Nhưng đối với setValue sẽ yêu cầu truyền đủ và chính xác object có cấu trúc giống với cấu trúc của form và nó sẽ báo lỗi khi
một control nào đó bị thừa hoặc thiếu.

+event ngSubmit và submit:
giống với template-driven form.

có thể kết hợp lồng formGroup:
với formGroup con thì => formGroupName với tên của group form sau đó sẽ đến các formControlName.

có 2 loại validator function:
1: sync validator( đồng bộ)
đây là các function để validate thường gặp , sẽ nhận đầu vào là 1 form control và trả về:
- một danh sách các validators erros.
- hoặc null tức là control này không có lỗi.
2: Async validator( bất đồng bộ)
đây là validator sẽ trả vê promise hoặc obserable , ví dụ như bạn muốn validate xem username đã tồn tại hay chưa thì sẽ gửi
1 request yêu cầu server để làm việc này,
lúc này chúng ta sẽ sử dụng custom validator.
cú pháp khi khởi tạo formControl trong form group bằng formBuilder sẽ hơi khác , thay vì 3 argument riêng biệt thì bạn sẽ truyền
vào một mảng với có 3 phần tử:
- đầu tiên là giá trị mặc định
- sync validator
- async validator

với sync validator: là các function validator thường gặp sẽ nhận đầu vào là control và trả về validator error hoặc null (thoả mãn).
sync validator sẽ thực hiện check trực tiếp giá trị trên control.
với async validator: là sẽ trả về các promise hoặc obserable. thông thường async validator được sử dụng để gửi yêu cầu lên server
để thực hiện check tồn tại ở db hoặc thoả mãn nghiệp vụ từ phía server.

có 2 cách custom async validator:
- sử dụng với 1 function nhận vào là 1 service, output trả về AsyncValidatorFn và sẽ return ra 1 function có tham số truyền vào
là control: AbstractControl và output sẽ trả về dưới dạng: Promise<ValidationErrors | null> | Observable<ValidationErrors | null>
- sử dụng directive implements AsyncValidator, trong đó có định nghĩa sẵn là bạn phải implements function validate. Sau đó bạn
sẽ thêm directive trong input của control bạn muốn trên template.

create form dynamic:
formArray: là 1 cách thay thế tuyệt vời cho formgroup cho việc quản lý số lượng control mà không biết chính xác chúng. Giống như form
group instance , bạn có thể insert or remove controls từ instance form array cùng với giá trị và validator sẽ được tính toán từ
các child controls. Tuy nhiên bạn sẽ không cần định nghĩa một key cho mỗi control by name, đó là sự lựa chọn tuyệt vời nếu như bạn
không biết số lượng control của mình.

trong form, trong khoảng thời gian delay 1 giây khi async validator đang đợi kết quả kiểm tra từ api thì các button thực hiện sẽ được
enable trở lại. nên nếu user nhanh tay vẫn có thể ấn button và vẫn thực hiện phần code thực hiện submit form.
để giải quyết vấn đề đó:
ý tưởng thay vì ngSubmit sẽ trigger thẳng hàm submit , thay vào đó mình sẽ tạo ra 1 subject tên formSubmit$ và handle chỉ khi status
của form là VALID thì formSubmit$ mới emit một value => call submitForm.

ngoài cách sử dụng dynamic form sử dụng entryComponent thì ta có thể sử dụng với angular Ivy:
sừ dụng với method async và thực hiện tạo biến để import component cần sử dụng
ví dụ:
async addynamic(){
  const {Component-name} = await import('link-componenet');
  // thực hiện tạo dynamic component here
}

khi bạn muốn tác động disable hoặc envalue ở trong reactive form control.
nếu như bạn khai báo:
 this.form = this.fb.group({
      name: [''],
    });

thì khi bạn sử dụng [disabled]="disabledName" trên form nó sẽ không hoạt động. do bạn chưa set disabled vào control của mình.
cách giải quyết:
1: khởi tạo lại form
this.form = this.fb.group({
  name: [{ value: '', disabled: false }],
});
2: tác động đến event trên template gọi xuống method và sử dụng FormControl.enable() hoặc FormControl.disable()
this.form.get('name').enable();
hoặc
this.form.get('name').disable();
3 sử dụng directive:
xem ở directives/disabbled-control.directive.ts

sự khác nhau giữa {{}} và []:
{{}}: là một form cơ bản của nội suy string. Nó là 1 cách đơn giản để thay thế HTML string cùng với kết quả của rằng buộc. và
trên form html sẽ nhân kết quả răng buộc đó.

[]: thì thực thi theo cách khác. bạn nên nghĩ nó như là sự điều khiển DOM sau khi HTML được xử lý bởi browser,
cho nên [src] binding nó sẽ không là "property" , không phải "attribute" của img

property binding nó sẽ không phải là nội suy string- nó có thể đảm bảo, giữ gìn kiểu của dữ liệu.

attribute: là các thuộc tính của các thẻ (ví dụ <a> có href, <input> có id) ngoài ra nằm trong DOM object phản ánh (liên hệ
chặt chẽ ) với các attribute của phần Html.
property: không có khái niệm trong Html, tồn tại trong đối tượng DOM object.

đối với attribute một khi đã được khởi tạo , giá trị của một HTML ATTRIBUTE bất kì sẽ không thay đổi.
Nhưng chúng ta có thể thay đổi giá trị của property trong đối tượng DOM

callback: gọi lại một function sẽ được thực thi sau khi một function khác đã được thực thi xong.
nhờ callback sẽ đảm bảo code sẽ không hoạt động trước khi các code khác hoàn thành việc thực hiện.

bind: là phương thức để tạo ra 1 function khi được call, từ khoá this sẽ đặt vào làm giá trị được cung cấp.
cùng với một chuỗi giá trị nhất định được cung cấp khi function mới được gọi.
Nói cách khác, bind giúp chúng ta tạo ra được "function" cùng với "this" được rằng buộc với object.
Nghĩa là nó giúp chúng ta lấy được property bên trong object ( nếu property đó tồn tại trong object và trong cả global).

micro frontends:
ý tưởng sẽ phân tách các ứng dụng thành các thành phần kết hợp với các tính năng , mỗi tính năng sẽ được phát triển bởi 1 team độc lập.
mỗi 1 project trong ứng dụng sẽ là chứa đựng 1 tính năng riêng biệt bao gồm từ db, backend, frontend.
phương pháp để xử dụng:
Iframe:
phương pháp này dễ để áp dụng nhưng có chứa nhiều giới hạn như việc navigation , thực thi các đoạn javascript từ Host app.
proxy like nginx:
phương pháp này yêu cầu việc phát triển các ứng dụng phải độc lập, ví dụ <host>/mainbox, <host>/calendar là các app frontend khác nhau.
phương pháp này có 1 vấn đề là khi navigation sang 1 app khác thì bạn sẽ bị reload giống với các ứnng dụng client - server thông thường.
web component:
đây là 1 công nghệ không quá mới trong thời gian trở lại đây. các framework áp dụng hoặc tạo ra custom elements khá nhiều. ví dụ như
angular elements, stencil,...
ví dụ <app-product></app-product>
Chúng có ưu điểm là bạn có thể tạo ra được các element và có thể sử dụng như một thẻ html thông thường ở bất kì cứ framework nào (framework Agnostic).
Orchestrator framework:
webpack 5 and module Federation, piral, luigi, single-spa (các công cụ, công nghệ phục vụ cho micro frontend).

để các micro frontend có thể chạy được trên cùng 1 app, chúng ta cần 1 shell (có thể gọi là 1 host). Trong shell sẽ seup 1 số thứ như routing hay
shared state ,... việc tạo ra 1 shell app có thể sẽ ảnh hưởng đến công nghệ áp dụng cho micro frontend.
ví dụ: nếu chúng ta lựa chọn angular hay reactive làm shell app thì các micro app sẽ phải có tần wrapper để có thể chạy được đó.
vì routing của các framework là specific cho từng loại framework. nên để route được và render đúng thì cần phải tuân thủ theo từng ràng buộc của
framework.

tạo ra app chính (sell):
npx @angular/cli@next new nam-project-shell --routing
tao các app micro con:
npx ng generate application nam-app (tạo bên trong project chính)
chúng ta cần custom webpack config nên cần install thêm @angular-builders/custom-webpack.
bổ sung thêm đoạn script trong package.json
ví dụ:
  "scripts": {
    "start:shell": "ng serve --project=acme-email-client --port 5200",
    "start:mailbox": "ng serve --project=mailbox --port 5300",
    "start:calendar": "ng serve --project=calendar --port 5400"
  },

để đảm bảo project sẽ sử dụng yarn khi cài đặt các package qua lệnh ng add có thể sử dụng:
npx ng config cli.packageManager yarn

bật tính năng module Federation:
-cần sử dụng custom webpack, để tạo ra file webpack config sau đó thay thế builder mặc định trong angular.json.
ví dụ: chúng ta tạo 2 file webpack.config.js và webpack.prod.config.js để sử dụng với môi trường dev và product.
-thay thế @angular-devkit/build-angular thành @angular-builders/custom-webpack.
-thêm config của webpack mà chúng ta vừa tạo.
-thực hiện config tương tự với các app micro.

tiếp đến chúng ta thực hiện config shell trong các file webpack custom:
-cấu hình port (publicPath) của shell cùng với tên (uniqueName) cho shell và mỗi 1 app.
-tiếp đến shell sẽ trỏ đến những app micro nào thì cần phần remotes chứa các app micro (bao gồm tên và path dẫn đến app đó).
nếu các micro app cùng sử dụng Angular thì chúng ta có thể share các phần code, module,service , component common nếu chúng ta muốn.

tiếp đến config routing trỏ đến các app micro:
-cần định nghĩa path cho các app micro.
-loadChildren với các import module sẽ được định nghĩa ở file 'types.d.ts'
-việc tạo file 'types.d.ts' nhằm mục đích báo cho typeScript là nó tồn tại (do đường dẫn 'mailbox/MailboxModule' không thật sử
tồn tại)
(nói cách khác là loadChildren sẽ trỏ đến module của app micro tương ứng qua tên của app micro được cấu hình ở app micro đó)

tiếp đến config các remote app:
-cấu hình port (publicPath) và uniqueName cho app micro.
-định nghĩa các thành phần như name, library, đặc biệt là file name cần giống với phần shell chúng ta đã config
mục đích của filename là để shell có thể truy cập vào app micro thông qua file js đó.
-phần exposes cho phép chúng ta config những gì sẽ được public ra bên ngoài
ở đây public ra bên ngoài là module của app micro để shell có thể trỏ đến module mong muốn trong app micro trong routing của shell.

tiếp đến config các router trong module của app micro:
tạo các router với các component tương ứng trong model của app micro.

giống với micro service muốn 1 project chạy được cần các micro chạy được
run các app micro chạy và sau đó run app shell.
